# Artiway 创艺工坊 - AI 电商工具平台

## 目录

- [一、项目概述](#一项目概述)
- [二、整体架构设计](#二整体架构设计)
- [三、多租户请求处理全流程](#三多租户请求处理全流程)
- [四、核心调度机制](#四核心调度机制)
- [五、技术难点与解决方案](#五技术难点与解决方案)
- [六、面试表达模板](#六面试表达模板)

---

## 一、项目概述

### 1.1 产品定位

Artiway 创艺工坊是一款**助力电商提效的 AI 工具平台**，核心价值：

- 无需聘请模特和昂贵的商拍团队
- 不需要租赁场地搭建场景
- 上传图片即可生成场景图和模特上身效果

### 1.2 核心功能矩阵

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           Artiway 功能矩阵                                   │
├─────────────────┬─────────────────┬─────────────────┬─────────────────────┤
│    AI 模特       │   AI 商品图      │   智能编辑       │    批量处理         │
├─────────────────┼─────────────────┼─────────────────┼─────────────────────┤
│ • 虚拟模特生成   │ • 场景图生成     │ • 智能裁剪       │ • 批量抠图          │
│ • 多姿势换装     │ • 背景替换       │ • AI 抠图        │ • 无损放大          │
│ • 真人模特效果   │ • 风格迁移       │ • AI 消除        │ • 批量格式转换      │
│                 │                 │ • 智能延展       │                    │
│                 │                 │ • 图像衍生       │                    │
│                 │                 │ • 局部重绘       │                    │
│                 │                 │ • 图生图         │                    │
│                 │                 │ • 高清修复       │                    │
└─────────────────┴─────────────────┴─────────────────┴─────────────────────┘
```

### 1.3 技术栈

| 层级 | 技术选型 |
|------|---------|
| **后端框架** | NestJS + TypeScript（深度使用） |
| **数据库** | PostgreSQL |
| **缓存** | Redis |
| **消息队列** | RabbitMQ |
| **ORM** | Prisma |
| **包管理** | pnpm + Monorepo |
| **API 文档** | Swagger（生成 RESTful Client，前端直接使用） |
| **容器化** | Docker Compose 一键启动 |
| **部署** | 阿里云 Kubernetes |

### 1.4 我负责的模块

```
业务模块：
├── 用户租户体系
├── 权限模块（RBAC）
├── 点数模块（充值、消费、活动赠送）
└── 微信支付

AI 模块：
├── AI 商品图
└── 智能编辑
    ├── 智能延展
    ├── 图像衍生
    └── 局部重绘

项目管理：
├── 需求讨论与技术方案制定
├── 代码 Review
├── 需求拆解与分配
└── 时间里程碑管控
```

---

## 二、整体架构设计

### 2.1 系统架构全景图

```
┌─────────────────────────────────────────────────────────────────────────────────────────┐
│                                    用户层                                                │
│                                                                                         │
│    ┌─────────────┐    ┌─────────────┐    ┌─────────────┐    ┌─────────────┐           │
│    │  Web 端     │    │  小程序      │    │  移动端      │    │  API 对接   │           │
│    └──────┬──────┘    └──────┬──────┘    └──────┬──────┘    └──────┬──────┘           │
│           │                  │                  │                  │                   │
└───────────┼──────────────────┼──────────────────┼──────────────────┼───────────────────┘
            │                  │                  │                  │
            └──────────────────┴──────────────────┴──────────────────┘
                                         │
                                         ▼
┌─────────────────────────────────────────────────────────────────────────────────────────┐
│                                   网关层                                                 │
│                                                                                         │
│    ┌─────────────────────────────────────────────────────────────────────────────┐     │
│    │                           API Gateway (Kong/Nginx)                           │     │
│    │                                                                             │     │
│    │   • 统一入口          • 限流熔断         • 身份认证         • 路由转发       │     │
│    └─────────────────────────────────────────────────────────────────────────────┘     │
│                                         │                                               │
└─────────────────────────────────────────┼───────────────────────────────────────────────┘
                                          │
                                          ▼
┌─────────────────────────────────────────────────────────────────────────────────────────┐
│                                   服务层                                                 │
│                                                                                         │
│    ┌─────────────┐    ┌─────────────┐    ┌─────────────┐    ┌─────────────┐           │
│    │ 用户服务    │    │ 租户服务    │    │ 权限服务    │    │ 点数服务    │           │
│    │            │    │            │    │            │    │            │           │
│    │ • 注册登录  │    │ • 租户管理  │    │ • RBAC     │    │ • 充值消费  │           │
│    │ • 用户信息  │    │ • 配额管理  │    │ • 资源控制  │    │ • 流水记录  │           │
│    └─────────────┘    └─────────────┘    └─────────────┘    └─────────────┘           │
│                                                                                         │
│    ┌─────────────┐    ┌─────────────┐    ┌─────────────┐    ┌─────────────┐           │
│    │ 支付服务    │    │ 任务服务    │    │ AI 调度服务 │    │ 存储服务    │           │
│    │            │    │            │    │            │    │            │           │
│    │ • 微信支付  │    │ • DAG 编排  │    │ • WFQ 调度  │    │ • OSS 上传  │           │
│    │ • 订单管理  │    │ • 状态管理  │    │ • 负载均衡  │    │ • CDN 加速  │           │
│    └─────────────┘    └─────────────┘    └─────────────┘    └─────────────┘           │
│                                                                                         │
└─────────────────────────────────────────┬───────────────────────────────────────────────┘
                                          │
                                          ▼
┌─────────────────────────────────────────────────────────────────────────────────────────┐
│                                   调度层                                                 │
│                                                                                         │
│    ┌─────────────────────────────────────────────────────────────────────────────┐     │
│    │                        WFQ 加权公平队列调度器                                  │     │
│    │                                                                             │     │
│    │   ┌─────────────────────────────────────────────────────────────────────┐   │     │
│    │   │              全局优先队列 (按虚拟完成时间 VFT 排序)                    │   │     │
│    │   │                                                                     │   │     │
│    │   │  [VIP_A:T1] [VIP_A:T2] [Std_B:T1] [VIP_A:T3] [Free_C:T1] ...       │   │     │
│    │   │   VFT=2      VFT=4      VFT=5      VFT=6      VFT=8                 │   │     │
│    │   └─────────────────────────────────────────────────────────────────────┘   │     │
│    └─────────────────────────────────────────────────────────────────────────────┘     │
│                                         │                                               │
│                                         │ 分发就绪任务                                   │
│                                         ▼                                               │
│    ┌─────────────────────────────────────────────────────────────────────────────┐     │
│    │                            RabbitMQ 消息队列                                  │     │
│    │                                                                             │     │
│    │   ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐    │     │
│    │   │ cutout   │  │ model    │  │ compose  │  │ extend   │  │ hd_fix   │    │     │
│    │   │ queue    │  │ queue    │  │ queue    │  │ queue    │  │ queue    │    │     │
│    │   └──────────┘  └──────────┘  └──────────┘  └──────────┘  └──────────┘    │     │
│    └─────────────────────────────────────────────────────────────────────────────┘     │
│                                                                                         │
└─────────────────────────────────────────┬───────────────────────────────────────────────┘
                                          │
                                          ▼
┌─────────────────────────────────────────────────────────────────────────────────────────┐
│                                   执行层                                                 │
│                                                                                         │
│    ┌─────────────────────────────────────────────────────────────────────────────┐     │
│    │                           Worker Pool (GPU 集群)                             │     │
│    │                                                                             │     │
│    │   ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐    │     │
│    │   │ Worker 1 │  │ Worker 2 │  │ Worker 3 │  │ Worker 4 │  │ Worker N │    │     │
│    │   │ (GPU)    │  │ (GPU)    │  │ (GPU)    │  │ (GPU)    │  │ (GPU)    │    │     │
│    │   └──────────┘  └──────────┘  └──────────┘  └──────────┘  └──────────┘    │     │
│    └─────────────────────────────────────────────────────────────────────────────┘     │
│                                         │                                               │
│                                         │ 调用 AI 模型                                   │
│                                         ▼                                               │
│    ┌─────────────────────────────────────────────────────────────────────────────┐     │
│    │                           AI 模型服务集群                                     │     │
│    │                                                                             │     │
│    │   ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐                   │     │
│    │   │ 抠图模型  │  │ 模特生成  │  │ 图像合成  │  │ 超分辨率  │                   │     │
│    │   └──────────┘  └──────────┘  └──────────┘  └──────────┘                   │     │
│    └─────────────────────────────────────────────────────────────────────────────┘     │
│                                                                                         │
└─────────────────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────────────────┐
│                                   数据层                                                 │
│                                                                                         │
│    ┌─────────────┐    ┌─────────────┐    ┌─────────────┐    ┌─────────────┐           │
│    │ PostgreSQL  │    │   Redis     │    │  RabbitMQ   │    │  OSS/CDN    │           │
│    │            │    │            │    │            │    │            │           │
│    │ • 业务数据  │    │ • 缓存      │    │ • 消息持久化 │    │ • 图片存储  │           │
│    │ • 任务状态  │    │ • 分布式锁  │    │ • 死信队列  │    │ • 静态资源  │           │
│    │ • 流水记录  │    │ • 会话管理  │    │            │    │            │           │
│    └─────────────┘    └─────────────┘    └─────────────┘    └─────────────┘           │
│                                                                                         │
└─────────────────────────────────────────────────────────────────────────────────────────┘
```

### 2.2 多租户架构设计

```
┌─────────────────────────────────────────────────────────────────────────────────────────┐
│                              多租户架构                                                  │
│                                                                                         │
│   ┌─────────────────────────────────────────────────────────────────────────────────┐  │
│   │                           租户配置层                                             │  │
│   │                                                                                 │  │
│   │   ┌───────────────┐   ┌───────────────┐   ┌───────────────┐                    │  │
│   │   │   VIP 租户    │   │  标准租户      │   │   免费租户     │                    │  │
│   │   │              │   │              │   │              │                    │  │
│   │   │ 权重: 5      │   │ 权重: 2      │   │ 权重: 1      │                    │  │
│   │   │ 并发: 20     │   │ 并发: 5      │   │ 并发: 2      │                    │  │
│   │   │ 队列深度: 100 │   │ 队列深度: 30  │   │ 队列深度: 10  │                    │  │
│   │   │ 优先级: HIGH  │   │ 优先级: NORMAL│   │ 优先级: LOW   │                    │  │
│   │   └───────────────┘   └───────────────┘   └───────────────┘                    │  │
│   └─────────────────────────────────────────────────────────────────────────────────┘  │
│                                                                                         │
│   ┌─────────────────────────────────────────────────────────────────────────────────┐  │
│   │                           数据隔离层                                             │  │
│   │                                                                                 │  │
│   │   方案一：共享数据库 + 租户ID字段                                                 │  │
│   │   ┌─────────────────────────────────────────────────────────────────────────┐  │  │
│   │   │  PostgreSQL                                                             │  │  │
│   │   │  ┌─────────────────────────────────────────────────────────────────┐   │  │  │
│   │   │  │ tasks 表                                                        │   │  │  │
│   │   │  │ ┌────────┬───────────┬────────┬─────────┬─────────────────────┐│   │  │  │
│   │   │  │ │   id   │ tenant_id │  type  │ status  │      payload       ││   │  │  │
│   │   │  │ ├────────┼───────────┼────────┼─────────┼─────────────────────┤│   │  │  │
│   │   │  │ │ task_1 │  VIP_A    │ model  │ PENDING │ {...}              ││   │  │  │
│   │   │  │ │ task_2 │  Std_B    │ cutout │ RUNNING │ {...}              ││   │  │  │
│   │   │  │ │ task_3 │  Free_C   │ extend │ DONE    │ {...}              ││   │  │  │
│   │   │  │ └────────┴───────────┴────────┴─────────┴─────────────────────┘│   │  │  │
│   │   │  └─────────────────────────────────────────────────────────────────┘   │  │  │
│   │   └─────────────────────────────────────────────────────────────────────────┘  │  │
│   │                                                                                 │  │
│   │   方案二：PostgreSQL Row-Level Security                                         │  │
│   │   ┌─────────────────────────────────────────────────────────────────────────┐  │  │
│   │   │  CREATE POLICY tenant_isolation ON tasks                                │  │  │
│   │   │    USING (tenant_id = current_setting('app.tenant_id'));               │  │  │
│   │   │                                                                         │  │  │
│   │   │  -- 即使应用层代码有漏洞，数据库层也会强制隔离                              │  │  │
│   │   └─────────────────────────────────────────────────────────────────────────┘  │  │
│   └─────────────────────────────────────────────────────────────────────────────────┘  │
│                                                                                         │
└─────────────────────────────────────────────────────────────────────────────────────────┘
```

---

## 三、多租户请求处理全流程

### 3.1 完整请求生命周期

让我们跟踪一个真实场景：**VIP 租户 A 和普通租户 B 同时提交 AI 模特图生成任务**

```
时间线
│
├─ T0: 请求到达
│      ┌─────────────────────────────────────────────────────────────────┐
│      │  VIP_A 请求：生成 3 个模特图（需要先抠图，再生成模特，最后合成）    │
│      │  Free_B 请求：生成 1 个模特图（同样流程）                         │
│      └─────────────────────────────────────────────────────────────────┘
│
├─ T1: 认证与限流
│      ┌─────────────────────────────────────────────────────────────────┐
│      │  1. JWT 解析，获取 tenantId, userId                             │
│      │  2. 查询租户配置（权重、配额、限流规则）                           │
│      │  3. 令牌桶限流检查                                               │
│      │  4. 点数余额检查                                                 │
│      └─────────────────────────────────────────────────────────────────┘
│
├─ T2: 点数冻结
│      ┌─────────────────────────────────────────────────────────────────┐
│      │  VIP_A：冻结 30 点（3 个模特图 × 10 点/个）                       │
│      │  Free_B：冻结 10 点（1 个模特图 × 10 点/个）                      │
│      │                                                                 │
│      │  采用乐观锁 + 版本号，防止并发超卖                                 │
│      └─────────────────────────────────────────────────────────────────┘
│
├─ T3: DAG 构建
│      ┌─────────────────────────────────────────────────────────────────┐
│      │  VIP_A 的 DAG:                                                  │
│      │                                                                 │
│      │       cutout_A ──┬──► model_A1 ──► compose_A1                   │
│      │                  ├──► model_A2 ──► compose_A2                   │
│      │                  └──► model_A3 ──► compose_A3                   │
│      │                                                                 │
│      │  Free_B 的 DAG:                                                 │
│      │                                                                 │
│      │       cutout_B ──► model_B1 ──► compose_B1                      │
│      │                                                                 │
│      │  计算入度表：                                                    │
│      │  VIP_A: cutout=0, model_1/2/3=1, compose_1/2/3=1               │
│      │  Free_B: cutout=0, model=1, compose=1                          │
│      └─────────────────────────────────────────────────────────────────┘
│
├─ T4: 入口任务推送到 WFQ
│      ┌─────────────────────────────────────────────────────────────────┐
│      │  入口任务（入度=0）：cutout_A, cutout_B                          │
│      │                                                                 │
│      │  WFQ 计算虚拟完成时间（VFT）：                                    │
│      │                                                                 │
│      │    cutout_A: VFT = 0 + 成本(6) / 权重(5) = 1.2                  │
│      │    cutout_B: VFT = 0 + 成本(6) / 权重(1) = 6.0                  │
│      │                                                                 │
│      │  WFQ 队列（按 VFT 排序）：                                        │
│      │    [cutout_A (1.2), cutout_B (6.0)]                             │
│      │         ▲                                                       │
│      │         └── VIP 任务排前面                                       │
│      └─────────────────────────────────────────────────────────────────┘
│
├─ T5: WFQ 调度 cutout_A
│      ┌─────────────────────────────────────────────────────────────────┐
│      │  1. 取出 VFT 最小的任务：cutout_A                                │
│      │  2. 更新全局虚拟时间：GVT = 1.2                                  │
│      │  3. 发送到 cutout 队列，Worker 开始执行                          │
│      └─────────────────────────────────────────────────────────────────┘
│
├─ T6: cutout_A 完成，触发 DAG 更新
│      ┌─────────────────────────────────────────────────────────────────┐
│      │  1. 更新 DAG 入度：                                             │
│      │     model_A1: 1 → 0 ✓ 就绪                                     │
│      │     model_A2: 1 → 0 ✓ 就绪                                     │
│      │     model_A3: 1 → 0 ✓ 就绪                                     │
│      │                                                                 │
│      │  2. 计算新任务的 VFT 并入队：                                    │
│      │     VIP_A lastVFT = 1.2                                        │
│      │     model_A1: VFT = max(1.2, 1.2) + 8/5 = 2.8                  │
│      │     model_A2: VFT = max(1.2, 2.8) + 8/5 = 4.4                  │
│      │     model_A3: VFT = max(1.2, 4.4) + 8/5 = 6.0                  │
│      │                                                                 │
│      │  3. 当前 WFQ 队列：                                              │
│      │     [model_A1(2.8), model_A2(4.4), cutout_B(6.0), model_A3(6.0)]│
│      └─────────────────────────────────────────────────────────────────┘
│
├─ T7: 继续调度 model_A1
│      ┌─────────────────────────────────────────────────────────────────┐
│      │  取出 model_A1，GVT = 2.8                                       │
│      │  VIP_A 继续获得调度（因为 VFT 更小）                              │
│      └─────────────────────────────────────────────────────────────────┘
│
├─ T8: 调度 model_A2
│      ┌─────────────────────────────────────────────────────────────────┐
│      │  取出 model_A2，GVT = 4.4                                       │
│      └─────────────────────────────────────────────────────────────────┘
│
├─ T9: 调度 cutout_B（Free_B 终于得到调度！）
│      ┌─────────────────────────────────────────────────────────────────┐
│      │  队列：[cutout_B(6.0), model_A3(6.0), ...]                      │
│      │  VFT 相同时可以按 FIFO 或随机选择                                 │
│      │  Free_B 虽然权重低，但没有被"饿死"                                │
│      └─────────────────────────────────────────────────────────────────┘
│
├─ T10-T15: 后续任务交替执行
│      ┌─────────────────────────────────────────────────────────────────┐
│      │  执行顺序示例：                                                  │
│      │  cutout_A → model_A1 → model_A2 → cutout_B → model_A3 →        │
│      │  → compose_A1 → model_B1 → compose_A2 → compose_A3 →            │
│      │  → compose_B1                                                   │
│      │                                                                 │
│      │  观察：两个租户的任务是交替执行的，而非一个执行完再执行另一个        │
│      └─────────────────────────────────────────────────────────────────┘
│
├─ T16: VIP_A DAG 完成
│      ┌─────────────────────────────────────────────────────────────────┐
│      │  1. 所有任务完成，汇总结果                                       │
│      │  2. 点数解冻 → 确认扣除                                          │
│      │  3. 记录消费流水                                                 │
│      │  4. WebSocket 推送结果给用户                                     │
│      └─────────────────────────────────────────────────────────────────┘
│
├─ T17: Free_B DAG 完成
│      ┌─────────────────────────────────────────────────────────────────┐
│      │  同上流程                                                        │
│      └─────────────────────────────────────────────────────────────────┘
│
▼
```

### 3.2 请求处理时序图

```
┌──────┐     ┌──────────┐     ┌──────────┐     ┌──────────┐     ┌──────────┐     ┌──────────┐
│Client│     │API Server│     │  Points  │     │   DAG    │     │   WFQ    │     │  Worker  │
└──┬───┘     └────┬─────┘     └────┬─────┘     └────┬─────┘     └────┬─────┘     └────┬─────┘
   │              │                │                │                │                │
   │  1.提交任务   │                │                │                │                │
   │─────────────▶│                │                │                │                │
   │              │                │                │                │                │
   │              │ 2.冻结点数      │                │                │                │
   │              │───────────────▶│                │                │                │
   │              │                │                │                │                │
   │              │◀───────────────│                │                │                │
   │              │   冻结成功      │                │                │                │
   │              │                │                │                │                │
   │              │ 3.构建DAG       │                │                │                │
   │              │───────────────────────────────▶│                │                │
   │              │                │                │                │                │
   │              │◀───────────────────────────────│                │                │
   │              │   返回入口任务  │                │                │                │
   │              │                │                │                │                │
   │              │ 4.入口任务入队  │                │                │                │
   │              │───────────────────────────────────────────────▶│                │
   │              │                │                │                │                │
   │◀─────────────│                │                │                │                │
   │ 返回任务ID    │                │                │                │                │
   │              │                │                │                │                │
   │              │                │                │ 5.调度任务      │                │
   │              │                │                │───────────────▶│                │
   │              │                │                │                │                │
   │              │                │                │                │ 6.执行AI任务   │
   │              │                │                │                │───────────────▶│
   │              │                │                │                │                │
   │              │                │                │                │◀───────────────│
   │              │                │                │                │   执行完成     │
   │              │                │                │                │                │
   │              │                │                │ 7.更新DAG入度  │                │
   │              │                │◀───────────────────────────────│                │
   │              │                │                │                │                │
   │              │                │ 8.新任务入队   │                │                │
   │              │                │───────────────────────────────▶│                │
   │              │                │                │                │                │
   │              │                │    ... 循环直到 DAG 完成 ...     │                │
   │              │                │                │                │                │
   │              │ 9.DAG完成回调   │                │                │                │
   │              │◀───────────────────────────────│                │                │
   │              │                │                │                │                │
   │              │ 10.确认扣点     │                │                │                │
   │              │───────────────▶│                │                │                │
   │              │                │                │                │                │
   │ 11.推送结果   │                │                │                │                │
   │◀─────────────│                │                │                │                │
   │              │                │                │                │                │
```

---

## 四、核心调度机制

### 4.1 WFQ（加权公平队列）详解

#### 4.1.1 核心概念

**虚拟时间（Virtual Time）**：一个抽象的时间刻度，用于衡量每个租户消耗的资源份额。

```
核心公式：
  VFT = max(全局虚拟时间, 上一个任务的VFT) + 任务成本 / 权重

关键洞察：
  - 权重越高的租户，VFT 增长越慢
  - VFT 越小的任务越先被调度
  - 因此高权重租户获得更多调度机会
```

#### 4.1.2 数学证明

```
设两个租户持续提交任务：
  租户A：权重 = W_A
  租户B：权重 = W_B

当两者累计VFT相等时：
  N_A × (C / W_A) = N_B × (C / W_B)
  
  N_A / N_B = W_A / W_B

结论：长期来看，租户获得的资源比例等于权重比
```

#### 4.1.3 代码实现

```typescript
interface Task {
  id: string;
  tenantId: string;
  dagId: string;
  type: string;
  cost: number;                    // 预估执行成本（GPU秒）
  virtualFinishTime: number;       // 虚拟完成时间
}

interface TenantState {
  tenantId: string;
  weight: number;                  // 租户权重
  lastVFT: number;                 // 上一个任务的VFT
}

class WFQScheduler {
  private globalVirtualTime: number = 0;
  private tenantStates: Map<string, TenantState> = new Map();
  private taskQueue: Task[] = [];  // 按 VFT 排序的优先队列

  /**
   * 任务入队
   */
  enqueue(task: Task): void {
    const tenant = this.tenantStates.get(task.tenantId)!;
    
    // 核心公式：计算虚拟完成时间
    const startTime = Math.max(this.globalVirtualTime, tenant.lastVFT);
    task.virtualFinishTime = startTime + task.cost / tenant.weight;
    
    // 更新租户状态
    tenant.lastVFT = task.virtualFinishTime;
    
    // 按 VFT 排序插入队列
    this.insertSorted(task);
  }

  /**
   * 调度：取出 VFT 最小的任务
   */
  dequeue(): Task | null {
    if (this.taskQueue.length === 0) return null;
    
    const task = this.taskQueue.shift()!;
    
    // 推进全局虚拟时间
    this.globalVirtualTime = task.virtualFinishTime;
    
    return task;
  }

  private insertSorted(task: Task): void {
    const idx = this.taskQueue.findIndex(
      t => t.virtualFinishTime > task.virtualFinishTime
    );
    if (idx === -1) {
      this.taskQueue.push(task);
    } else {
      this.taskQueue.splice(idx, 0, task);
    }
  }
}
```

#### 4.1.4 调度示例

```
场景：VIP_A (权重=5) 和 Free_B (权重=1) 同时提交任务

初始：GVT = 0, VIP_A.lastVFT = 0, Free_B.lastVFT = 0

任务入队：
  VIP_A.task1 (成本=10): VFT = 0 + 10/5 = 2
  VIP_A.task2 (成本=10): VFT = 2 + 10/5 = 4
  VIP_A.task3 (成本=10): VFT = 4 + 10/5 = 6
  Free_B.task1 (成本=10): VFT = 0 + 10/1 = 10
  Free_B.task2 (成本=10): VFT = 10 + 10/1 = 20

队列状态：
  [A.t1(2), A.t2(4), A.t3(6), B.t1(10), B.t2(20)]

调度顺序：
  A.t1 → A.t2 → A.t3 → B.t1 → B.t2

资源分配比例：3:2（接近权重比 5:1）

注：如果任务持续提交，长期比例会精确收敛到 5:1
```

### 4.2 DAG（有向无环图）调度详解

#### 4.2.1 核心概念

```
DAG = Directed Acyclic Graph = 有向无环图

作用：管理任务内部的依赖关系

关键属性：
  - 入度（In-Degree）：有多少任务指向自己 = 依赖多少前置任务
  - 入度为 0：无依赖，可以立即执行
```

#### 4.2.2 拓扑排序算法（Kahn）

```
1. 找出所有入度为 0 的节点，放入就绪队列
2. 从就绪队列取出一个节点执行
3. 将该节点的所有后继节点的入度 -1
4. 如果某后继节点入度变为 0，加入就绪队列
5. 重复 2-4，直到所有节点完成
```

#### 4.2.3 代码实现

```typescript
type TaskStatus = 'PENDING' | 'READY' | 'RUNNING' | 'COMPLETED' | 'FAILED' | 'CANCELLED';

interface TaskNode {
  id: string;
  type: string;
  dependencies: string[];    // 依赖的任务ID
  dependents: string[];      // 被哪些任务依赖（反向索引）
  status: TaskStatus;
}

interface DAGState {
  dagId: string;
  tenantId: string;
  tasks: Map<string, TaskNode>;
  inDegree: Map<string, number>;
}

class DAGScheduler {
  
  /**
   * 获取所有就绪任务（入度为0且状态为PENDING）
   */
  getReadyTasks(dag: DAGState): TaskNode[] {
    const ready: TaskNode[] = [];
    
    for (const [taskId, task] of dag.tasks) {
      if (dag.inDegree.get(taskId) === 0 && task.status === 'PENDING') {
        task.status = 'READY';
        ready.push(task);
      }
    }
    
    return ready;
  }

  /**
   * 任务完成后更新DAG
   */
  onTaskComplete(dag: DAGState, taskId: string): TaskNode[] {
    const task = dag.tasks.get(taskId)!;
    task.status = 'COMPLETED';
    
    const newReady: TaskNode[] = [];
    
    // 更新所有后继任务的入度
    for (const dependentId of task.dependents) {
      const currentInDegree = dag.inDegree.get(dependentId)!;
      const newInDegree = currentInDegree - 1;
      dag.inDegree.set(dependentId, newInDegree);
      
      // 如果入度变为0，加入就绪队列
      if (newInDegree === 0) {
        const dependent = dag.tasks.get(dependentId)!;
        dependent.status = 'READY';
        newReady.push(dependent);
      }
    }
    
    return newReady;
  }

  /**
   * 任务失败时级联取消下游任务
   */
  onTaskFailed(dag: DAGState, taskId: string): string[] {
    const cancelled: string[] = [];
    const queue = [taskId];
    
    while (queue.length > 0) {
      const current = queue.shift()!;
      const task = dag.tasks.get(current)!;
      
      for (const dependentId of task.dependents) {
        const dependent = dag.tasks.get(dependentId)!;
        if (dependent.status === 'PENDING' || dependent.status === 'READY') {
          dependent.status = 'CANCELLED';
          cancelled.push(dependentId);
          queue.push(dependentId);
        }
      }
    }
    
    return cancelled;
  }
}
```

#### 4.2.4 DAG 示例

```
用户请求：生成 3 个模特图

DAG 结构：
                cutout
                  │
        ┌─────────┼─────────┐
        ▼         ▼         ▼
     model_1   model_2   model_3
        │         │         │
        ▼         ▼         ▼
    compose_1 compose_2 compose_3

入度表：
  cutout: 0      ← 入口任务
  model_1: 1
  model_2: 1
  model_3: 1
  compose_1: 1
  compose_2: 1
  compose_3: 1

执行流程：
  Step 1: cutout 入度=0，执行
  Step 2: cutout 完成，model_1/2/3 入度→0，可并行执行
  Step 3: model_1 完成，compose_1 入度→0，执行
  Step 4: model_2 完成，compose_2 入度→0，执行
  Step 5: model_3 完成，compose_3 入度→0，执行
```

### 4.3 WFQ + DAG 双层协作

```
┌─────────────────────────────────────────────────────────────────────────────────────────┐
│                           双层调度协作流程                                               │
│                                                                                         │
│   用户请求                                                                               │
│      │                                                                                  │
│      ▼                                                                                  │
│   ┌─────────────────────────────────────────────────────────────────────────────────┐  │
│   │                              DAG 构建                                            │  │
│   │                                                                                 │  │
│   │   1. 解析任务依赖关系                                                            │  │
│   │   2. 构建 DAG 图结构                                                             │  │
│   │   3. 计算每个节点的入度                                                          │  │
│   │   4. 识别入口任务（入度=0）                                                       │  │
│   └─────────────────────────────────┬───────────────────────────────────────────────┘  │
│                                     │                                                   │
│                                     │ 入口任务                                          │
│                                     ▼                                                   │
│   ┌─────────────────────────────────────────────────────────────────────────────────┐  │
│   │                              WFQ 队列                                            │  │
│   │                                                                                 │  │
│   │   1. 计算任务的虚拟完成时间（VFT）                                                │  │
│   │   2. 按 VFT 排序插入优先队列                                                      │  │
│   │   3. 调度 VFT 最小的任务执行                                                      │  │
│   └─────────────────────────────────┬───────────────────────────────────────────────┘  │
│                                     │                                                   │
│                                     │ 分发任务                                          │
│                                     ▼                                                   │
│   ┌─────────────────────────────────────────────────────────────────────────────────┐  │
│   │                              Worker 执行                                         │  │
│   │                                                                                 │  │
│   │   1. 接收任务                                                                    │  │
│   │   2. 调用 AI 模型执行                                                            │  │
│   │   3. 上报心跳（证明任务还在执行）                                                  │  │
│   │   4. 返回执行结果                                                                │  │
│   └─────────────────────────────────┬───────────────────────────────────────────────┘  │
│                                     │                                                   │
│                                     │ 任务完成                                          │
│                                     ▼                                                   │
│   ┌─────────────────────────────────────────────────────────────────────────────────┐  │
│   │                              DAG 更新                                            │  │
│   │                                                                                 │  │
│   │   1. 标记当前任务为已完成                                                         │  │
│   │   2. 更新后继任务的入度（-1）                                                     │  │
│   │   3. 检查是否有新的入度为 0 的任务                                                │  │
│   │   4. 将新就绪任务推送到 WFQ 队列                                                  │  │
│   └─────────────────────────────────┬───────────────────────────────────────────────┘  │
│                                     │                                                   │
│                                     │ 循环                                              │
│                                     ▼                                                   │
│                            DAG 全部完成？                                               │
│                                  │                                                      │
│                    ┌─────────────┴─────────────┐                                       │
│                    │ 否                         │ 是                                    │
│                    │                           │                                       │
│                    ▼                           ▼                                       │
│              继续调度 ─────────────────▶ 汇总结果，回调用户                              │
│                                                                                         │
└─────────────────────────────────────────────────────────────────────────────────────────┘
```

---

## 五、技术难点与解决方案

### 5.1 点数并发扣减

#### 问题

```
用户账户有 100 点
同时发起 3 个 AI 任务，每个消耗 50 点

风险：如果处理不当，3 个任务都成功了（超卖）
```

#### 解决方案：乐观锁 + 版本号 + TCC

```typescript
// 数据模型
model UserPoints {
  id        String   @id
  userId    String   @unique
  balance   Int      @default(0)    // 可用余额
  frozen    Int      @default(0)    // 冻结金额
  version   Int      @default(0)    // 乐观锁版本号
}

// TCC 模式
class PointsService {
  
  // Try: 冻结点数
  async freeze(userId: string, amount: number, taskId: string): Promise<boolean> {
    const result = await this.prisma.userPoints.updateMany({
      where: {
        userId,
        balance: { gte: amount },
        version: currentVersion  // 乐观锁
      },
      data: {
        balance: { decrement: amount },
        frozen: { increment: amount },
        version: { increment: 1 }
      }
    });
    
    return result.count === 1;
  }

  // Confirm: 确认扣除
  async confirm(userId: string, amount: number, taskId: string): Promise<void> {
    await this.prisma.userPoints.update({
      where: { userId },
      data: {
        frozen: { decrement: amount }
      }
    });
  }

  // Cancel: 回滚
  async cancel(userId: string, amount: number, taskId: string): Promise<void> {
    await this.prisma.userPoints.update({
      where: { userId },
      data: {
        frozen: { decrement: amount },
        balance: { increment: amount }
      }
    });
  }
}
```

### 5.2 微信支付可靠性

#### 问题

```
1. 回调丢失：用户付了钱但系统没收到通知
2. 回调重复：同一笔支付通知多次，导致重复充值
3. 状态不一致：订单状态和微信侧状态不符
```

#### 解决方案：三重保障

```typescript
// 保障1：回调幂等
async handleCallback(notification: WechatPayNotification): Promise<void> {
  const lock = await this.redlock.acquire([`pay:${orderId}`], 10000);
  
  try {
    const order = await this.prisma.order.findUnique({ where: { orderId } });
    
    // 幂等检查：已处理的订单直接返回
    if (order.status === 'PAID' || order.status === 'COMPLETED') {
      return;
    }
    
    await this.processPayment(order, notification);
  } finally {
    await lock.release();
  }
}

// 保障2：主动查询补偿
@Cron('*/5 * * * *')
async reconcilePendingOrders(): Promise<void> {
  const pendingOrders = await this.prisma.order.findMany({
    where: {
      status: 'PAYING',
      createdAt: { lt: new Date(Date.now() - 5 * 60 * 1000) }
    }
  });

  for (const order of pendingOrders) {
    const wechatResult = await this.wechatClient.queryOrder(order.orderId);
    if (wechatResult.trade_state === 'SUCCESS') {
      await this.processPayment(order, wechatResult);
    }
  }
}

// 保障3：每日对账
@Cron('0 2 * * *')
async dailyReconciliation(): Promise<void> {
  const wechatBill = await this.wechatClient.downloadBill(yesterday);
  const ourOrders = await this.getYesterdayOrders();
  const discrepancies = this.compare(wechatBill, ourOrders);
  
  if (discrepancies.length > 0) {
    await this.alertService.send('支付对账异常', discrepancies);
  }
}
```

### 5.3 长任务状态机

#### 问题

```
AI 任务执行时间 10s ~ 2min，可能：
1. Worker 宕机，任务丢失
2. 任务超时，需要重试
3. 用户需要看到实时进度
```

#### 解决方案：有限状态机 + 心跳 + 超时重试

```typescript
// 状态转换规则
const STATE_TRANSITIONS = {
  PENDING:    ['QUEUED', 'CANCELLED'],
  QUEUED:     ['PROCESSING', 'CANCELLED', 'TIMEOUT'],
  PROCESSING: ['COMPLETED', 'FAILED', 'TIMEOUT'],
  COMPLETED:  [],  // 终态
  FAILED:     ['PENDING'],  // 可重试
  TIMEOUT:    ['PENDING'],  // 可重试
  CANCELLED:  []   // 终态
};

// 心跳机制
class TaskHeartbeat {
  async report(taskId: string, progress: number): Promise<void> {
    await this.redis.setex(`heartbeat:${taskId}`, 30, JSON.stringify({
      progress,
      timestamp: Date.now()
    }));
  }
}

// 超时检测
@Cron('*/30 * * * * *')
async checkTimeouts(): Promise<void> {
  const processingTasks = await this.prisma.task.findMany({
    where: { status: 'PROCESSING' }
  });

  for (const task of processingTasks) {
    const heartbeat = await this.redis.get(`heartbeat:${task.id}`);
    if (!heartbeat) {
      // 无心跳，标记超时并重试
      await this.stateMachine.transition(task.id, 'TIMEOUT');
      if (task.retryCount < 3) {
        await this.stateMachine.transition(task.id, 'PENDING');
        await this.taskQueue.enqueue(task);
      }
    }
  }
}
```

### 5.4 多租户数据隔离

#### 问题

```
多个租户共用同一数据库，需要：
1. 租户 A 绝对看不到租户 B 的数据
2. 开发者无需每个查询都手动加 tenantId
3. 即使代码有漏洞，也不会泄露数据
```

#### 解决方案：Prisma 中间件 + PostgreSQL RLS

```typescript
// Prisma 中间件：自动注入 tenantId
const tenantMiddleware: Prisma.Middleware = async (params, next) => {
  const tenantId = AsyncLocalStorage.getStore()?.tenantId;
  
  if (!tenantId) return next(params);
  
  const tenantModels = ['Task', 'Order', 'Image', 'Points'];
  if (!tenantModels.includes(params.model)) return next(params);

  // 自动注入 tenantId 条件
  if (params.action === 'findMany' || params.action === 'findFirst') {
    params.args.where = { ...params.args.where, tenantId };
  }
  
  if (params.action === 'create') {
    params.args.data = { ...params.args.data, tenantId };
  }

  return next(params);
};

// PostgreSQL RLS：数据库层面强制隔离
-- CREATE POLICY tenant_isolation ON tasks
--   USING (tenant_id = current_setting('app.tenant_id'));
```

### 5.5 分布式锁与续期

#### 问题

```
1. 同一任务不能被多个 Worker 同时执行
2. Worker 宕机后，锁要能自动释放
3. 任务执行时间不确定，锁可能需要续期
```

#### 解决方案：Redlock + 看门狗

```typescript
class DistributedLock {
  async acquireWithWatchdog<T>(
    resource: string,
    ttl: number,
    fn: () => Promise<T>
  ): Promise<T> {
    const lock = await this.redlock.acquire([resource], ttl);
    
    // 启动看门狗，定期续期
    const watchdog = setInterval(async () => {
      try {
        await lock.extend(ttl);
      } catch (error) {
        clearInterval(watchdog);
      }
    }, ttl / 3);

    try {
      return await fn();
    } finally {
      clearInterval(watchdog);
      await lock.release();
    }
  }
}
```

---

## 六、面试表达模板

### 6.1 项目介绍（30秒版）

> Artiway 创艺工坊是一款 AI 电商工具平台，帮助商家无需专业模特和摄影团队，通过 AI 生成商品模特图和场景图。
>
> 我负责用户租户体系、权限模块、点数系统、微信支付，以及 AI 商品图和智能编辑模块。同时兼任项目经理，负责需求拆解和进度管控。
>
> 技术栈是 NestJS + TypeScript + PostgreSQL + Redis + RabbitMQ，采用 Monorepo 架构，K8s 部署。

### 6.2 技术难点回答（WFQ + DAG）

> **面试官**：你在多租户项目中遇到的最大技术难点是什么？
>
> **回答**：
>
> 我们平台最核心的难点是**多租户 AI 任务调度的资源隔离与公平调度**。
>
> 问题的复杂性在于：AI 任务执行时间长（10秒到2分钟），而且有依赖关系（比如生成模特图需要先抠图、再生成模特、最后合成）。我们需要同时满足：VIP 租户优先保障、普通租户不被饿死、系统吞吐量最大化。
>
> 我们设计了**双层调度架构**：
>
> **第一层是 WFQ（加权公平队列）**，解决租户间资源分配。借鉴网络 QoS 的思想，通过虚拟时间戳机制，权重越高的租户 VFT 增长越慢，因此获得更多调度机会。数学上可以证明，长期资源分配比例精确等于权重比。
>
> **第二层是 DAG 调度器**，解决单个请求内的任务依赖。用拓扑排序管理依赖关系，入度为 0 的任务才能执行，实现最大并行度。
>
> 两者的协作方式是：请求到达时构建 DAG，将入口任务推送到 WFQ；WFQ 调度任务执行；任务完成后更新 DAG 入度，新就绪的任务再推回 WFQ。
>
> 这套方案上线后，VIP 租户的平均响应时间降低了 60%，同时普通租户的任务也能在合理时间内完成。

### 6.3 追问应对

| 追问 | 回答要点 |
|------|---------|
| WFQ 和简单优先级有什么区别？ | 优先级队列会饿死低优先级；WFQ 通过虚拟时间保证比例公平 |
| 虚拟时间怎么理解？ | 权重越高，虚拟时间流逝越慢；VFT = 成本/权重，权重高的 VFT 增长慢，排名靠前 |
| DAG 任务失败怎么处理？ | 级联取消所有下游依赖任务，同时支持重试策略 |
| 分布式环境下怎么同步 WFQ 状态？ | 队列存在 Redis，用 Lua 脚本保证原子性 |
| 点数扣减怎么保证一致性？ | TCC 模式：先冻结，任务完成后确认扣除，失败则回滚 |
| 支付回调丢失怎么办？ | 三重保障：回调幂等、主动查询补偿、每日对账 |

### 6.4 项目亮点总结

```
1. 架构设计：双层调度（WFQ + DAG）解决多租户资源公平与任务依赖
2. 并发控制：乐观锁 + 版本号防止点数超卖
3. 可靠性设计：TCC 事务 + 三重支付保障 + 状态机 + 心跳超时
4. 安全隔离：Prisma 中间件 + PostgreSQL RLS 双保险
5. 工程实践：Monorepo + Swagger + TypeScript 全链路类型安全
6. 项目管理：需求拆解、里程碑管控、代码 Review
```

---

## 附录：关键代码片段

### A. 完整的 WFQ + DAG 调度器

```typescript
// 见上文详细实现
```

### B. 点数 TCC 事务

```typescript
// 见上文详细实现
```

### C. 支付三重保障

```typescript
// 见上文详细实现
```

### D. 长任务状态机

```typescript
// 见上文详细实现
```

