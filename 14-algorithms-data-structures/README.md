# 算法与数据结构

## 数据结构

### 线性结构
- [ ] 数组（Array）
- [ ] 链表（Linked List）
- [ ] 栈（Stack）
- [ ] 队列（Queue）
- [ ] 双端队列（Deque）

### 树结构
- [ ] 二叉树（Binary Tree）
- [ ] 二叉搜索树（BST）
- [ ] 平衡二叉树（AVL）
- [ ] 红黑树
- [ ] B 树与 B+ 树
- [ ] 堆（Heap）
- [ ] 字典树（Trie）

### 图结构
- [ ] 图的表示（邻接矩阵、邻接表）
- [ ] 图的遍历（DFS、BFS）
- [ ] 最短路径算法
- [ ] 最小生成树

### 哈希表
- [ ] 哈希函数
- [ ] 冲突解决（链表法、开放寻址）
- [ ] JavaScript Map 与 Set

## 算法

### 排序算法
- [ ] 冒泡排序
- [ ] 选择排序
- [ ] 插入排序
- [ ] 归并排序
- [ ] 快速排序
- [ ] 堆排序
- [ ] 计数排序
- [ ] 桶排序
- [ ] 基数排序
- [ ] 排序算法对比

### 搜索算法
- [ ] 二分查找
- [ ] 深度优先搜索（DFS）
- [ ] 广度优先搜索（BFS）
- [ ] 回溯算法

### 动态规划
- [ ] 动态规划思想
- [ ] 记忆化搜索
- [ ] 经典 DP 问题
  - [ ] 斐波那契数列
  - [ ] 背包问题
  - [ ] 最长公共子序列
  - [ ] 最长递增子序列
  - [ ] 编辑距离

### 贪心算法
- [ ] 贪心思想
- [ ] 经典贪心问题

### 分治算法
- [ ] 分治思想
- [ ] 经典分治问题

### 字符串算法
- [ ] KMP 算法
- [ ] 字符串匹配
- [ ] 正则表达式

## 算法复杂度
- [ ] 时间复杂度分析
- [ ] 空间复杂度分析
- [ ] Big O 表示法
- [ ] 最好、最坏、平均情况

## LeetCode 经典题目

### 数组
- [ ] 两数之和
- [ ] 三数之和
- [ ] 买卖股票的最佳时机
- [ ] 最大子数组和
- [ ] 合并区间

### 链表
- [ ] 反转链表
- [ ] 环形链表
- [ ] 合并两个有序链表
- [ ] 链表的中间节点

### 树
- [ ] 二叉树的遍历
- [ ] 二叉树的最大深度
- [ ] 验证二叉搜索树
- [ ] 二叉树的最近公共祖先

### 动态规划
- [ ] 爬楼梯
- [ ] 零钱兑换
- [ ] 最长回文子串
- [ ] 打家劫舍

### 字符串
- [ ] 最长公共前缀
- [ ] 有效的括号
- [ ] 最长回文子串

## JavaScript 特定
- [ ] Array 方法复杂度
- [ ] Object vs Map 性能
- [ ] 闭包与内存

## 刷题策略
- [ ] LeetCode 刷题顺序
- [ ] 题目分类
- [ ] 常见解题模式
- [ ] 面试高频题

## 常见面试题
- [ ] 手写快速排序
- [ ] 手写二分查找
- [ ] 实现 LRU 缓存
- [ ] 两个栈实现队列

